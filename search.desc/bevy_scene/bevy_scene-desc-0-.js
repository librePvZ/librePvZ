searchState.loadedDescShard("bevy_scene", 0, "Provides scene definition, instantiation and …\nContains the set of permitted types by their <code>TypeId</code>.\nContains the set of prohibited types by their <code>TypeId</code>.\nA reflection-powered serializable representation of an …\nA collection of serializable resources and dynamic …\nA <code>DynamicScene</code> builder, used to build a scene from a <code>World</code> …\nA component bundle for a <code>DynamicScene</code> root.\nUnique id identifying a scene instance.\nInformation about a scene instance.\nAn IO Error\nScene contains a proxy without a represented type.\nScene with the given id does not exist.\nDynamic scene with the given id does not exist.\nA RON Error\nTo spawn a scene, you can use either:\nA component bundle for a <code>Scene</code> root.\nA filter used to control which types can be added to a …\n<code>InstanceId</code> of a spawned scene. It can be used with the …\nEmitted when <code>crate::SceneInstance</code> becomes ready to use.\nAsset loader for a Bevy dynamic scene (<code>.scn</code> / <code>.scn.ron</code>).\nPossible errors that can be produced by <code>SceneLoader</code>\nPlugin that provides scene functionality to an <code>App</code>.\nErrors that can occur when spawning a scene.\nHandles spawning and despawning scenes in the world, …\nScene contains an unregistered type which has a <code>TypePath</code>.\nScene contains an unregistered component type.\nScene contains an unregistered resource type.\nScene contains an unregistered type.\nRepresents an unset filter.\nAllows the given component type, <code>T</code>, to be included in the …\nAllow the given type, <code>T</code>.\nUpdates the filter to allow all component types.\nCreates a filter where all types are allowed.\nUpdates the filter to allow all resource types.\nAllow the given type.\nAllows the given resource type, <code>T</code>, to be included in the …\nConsume the builder, producing a <code>DynamicScene</code>.\nClone the scene.\nA vector of boxed components that belong to the given …\nDenies the given component type, <code>T</code>, from being included in …\nDeny the given type, <code>T</code>.\nUpdates the filter to deny all component types.\nCreates a filter where all types are denied.\nUpdates the filter to deny all resource types.\nDeny the given type.\nDenies the given resource type, <code>T</code>, from being included in …\nSchedule the despawn of all instances of the provided …\nSchedule the despawn of a scene instance, removing all its …\nImmediately despawns a scene instance, removing all its …\nImmediately despawns all scene instances scheduled for …\nImmediately despawns all scenes scheduled for despawn by …\nImmediately despawns all instances of a dynamic scene.\nEntities contained in the dynamic scene.\nThe identifier of the entity, unique within a scene (and …\nMapping of entities from the scene world to the instance …\nExtract entities from the builder’s <code>World</code>.\nExtract one entity from the builder’s <code>World</code>.\nExtract resources from the builder’s <code>World</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new scene from a given dynamic scene.\nCreate a new dynamic scene from a given scene.\nPrepare a builder that will extract entities and their …\nCreate a new dynamic scene from a given world.\nGlobal transform of the scene root entity.\nGlobal transform of the scene root entity.\nInherited visibility of the scene root entity.\nInherited visibility of the scene root entity.\nCheck that an scene instance spawned previously is ready …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the given type, <code>T</code>, is allowed by the …\nReturns true if the given type is allowed by the filter.\nReturns true if the given type, <code>T</code>, is denied by the filter.\nReturns true if the given type is denied by the filter.\nReturns true if there are zero items in the filter.\nReturns an iterator over the items in the filter.\nGet an iterator over the entities in an instance, once it…\nReturns the number of items in the filter.\nProcesses the asset in an asynchronous closure.\nCreates a new scene with the given world.\nEntity to which the scene was spawned as a child.\nDespawns all entities with no components.\nResources stored in the dynamic scene.\nRusty Object Notation, a crate used to serialize and …\nHandle to the scene to spawn.\nHandle to the scene to spawn.\nSystem that will spawn scenes from <code>SceneBundle</code>.\nSystem that handles scheduled scene instance spawning and …\n<code>serde</code> serialization and deserialization implementation for …\nSerialize this dynamic scene into the official Bevy scene …\nSerialize a given Rust data structure into rust object …\nSchedule the spawn of a new instance of the provided scene.\nSchedule the spawn of a new instance of the provided scene …\nSchedule the spawn of a new instance of the provided …\nSchedule the spawn of a new instance of the provided …\nImmediately spawns a new instance of the provided dynamic …\nImmediately spawns all scenes scheduled for spawn.\nImmediately spawns a new instance of the provided scene.\nTransform of the scene root entity.\nTransform of the scene root entity.\nIterate through all instances of the provided scenes and …\nAlgorithmically-computed visibility of the scene root …\nAlgorithmically-computed visibility of the scene root …\nUser-driven visibility of the scene root entity.\nUser-driven visibility of the scene root entity.\nSpecify a custom component <code>SceneFilter</code> to be used with …\nSpecify a custom resource <code>SceneFilter</code> to be used with this …\nThe world of the scene, containing its entities and …\nWrite the resources, the dynamic entities, and their …\nWrite the resources, the dynamic entities, and their …\nWrite the entities and their corresponding components to …\nId of the non-existent dynamic scene.\nId of the non-existent scene.\nThe type name for the unregistered type.\nType of the unregistered component.\nType of the unregistered resource.\nThe unregistered type.\nThe dynamic instance type.\nName of the serialized component field in an entity struct.\nName of the serialized entity struct type.\nHandles serialization of multiple entities as a map of …\nHandles entity serialization as a map of component type to …\nName of the serialized entities field in a scene struct.\nName of the serialized resources field in a scene struct.\nName of the serialized scene struct type.\nHandles scene deserialization.\nHandles deserialization for a collection of entities.\nHandle deserialization of an entity and its components.\nHandles deserialization of a sequence of values with …\nHandles serializing a list of values with a unique type as …\nSerializer for a <code>DynamicScene</code>.\nThe entities to serialize.\nThe entity to serialize.\nId of the deserialized entity.\nList of boxed values of unique type to serialize.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new serializer from a <code>DynamicScene</code> and an …\nThe type registry containing the types present in the …\nType registry in which the component types used by the …\nType registry in which the component types used by the …\nType registry in which the types used in <code>entries</code> are …\nType registry in which the types of the values to …\nThe scene to serialize.\nType registry in which the components and resources types …\nType registry in which the component types used by the …\nType registry in which the component types used by the …")
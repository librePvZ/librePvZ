searchState.loadedDescShard("bevy_asset_loader", 0, "The goal of this crate is to offer an easy way for bevy …\nTrait definition for types that represent a collection of …\nTypes and infrastructure to load and use dynamic assets\nA game state responsible for loading assets\nTrait definition for mapped assets collection\nMost commonly used types\nTrait to mark a struct as a collection of assets\nDerive macro for <code>AssetCollection</code>\nExtension trait for <code>App</code> enabling initialisation of asset …\nExtension trait for <code>World</code> enabling initialisation of asset …\nCreate a new asset collection from the <code>AssetServer</code>\nInitialise an <code>AssetCollection</code>\nInitialise an <code>AssetCollection</code>\nStart loading all the assets in the collection\nDynamic asset that is defined by multiple handles\nAny type implementing this trait can be assigned to asset …\nThis traits describes types that contain asset …\nResource keeping track of dynamic asset collection files …\nDifferent typed that can generate the asset field value of …\nResource to dynamically resolve keys to assets.\nDynamic asset that is defined by a single handle\nReturn the handle(s) defining this asset\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the asset corresponding to the given key.\nGet all currently registered files to be loaded for the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate over all the known key→asset mappings\nReturn handles to all required asset paths\nRegister all dynamic assets inside the collection in the …\nSet the corresponding dynamic asset for the given key.\nRegister a file containing dynamic asset definitions to be …\nA Bevy plugin to configure automatic asset loading\nExtension trait for Bevy Apps to add loading states …\nResource to store the schedules for loading states\nSystems in this set check the loading state of assets.\nAdd an <code>AssetCollection</code> to the <code>LoadingState</code>\nRegister files to be loaded as a certain type of …\nAdd a loading state to your app\nFinish configuring the <code>LoadingState</code>\nConfiguration of loading states\nConfigure an existing loading state with, for example, …\nThe <code>LoadingState</code> will set this Bevy <code>State</code> after all asset …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdd any <code>FromWorld</code> resource to be initialized after all …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>LoadingState</code>\nThe <code>LoadingState</code> will set this Bevy <code>State</code> if an asset …\nRegister a new <code>DynamicAssetCollection</code> to be handled in the …\nMap to store a schedule per loading state\nMethods to configure a loading state\nCan be used to add new asset collections or similar …\nReturns the argument unchanged.\nThe resource will be initialized at the end of the loading …\nCalls <code>U::from(self)</code>.\nAdd the given collection to the loading state.\nCreate a new configuration for the given loading state\nRegister a custom dynamic asset collection type\nAdd a file containing dynamic assets to the loading state. …\nA <code>MapKey</code> that uses the <code>file_name</code> of the asset’s path as …\nA <code>MapKey</code> that uses the <code>file_stem</code> of the asset’s path as …\nA <code>MapKey</code> that uses the <code>label</code> of the asset’s path as key.\nA type that can be used as key for mapped asset collection.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates the key from the path of the asset.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")
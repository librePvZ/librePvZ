searchState.loadedDescShard("bincode", 0, "Bincode is a crate for encoding and decoding using a tiny …\nAttempt to decode a given type <code>D</code> from the given slice. …\nThe config module is used to change the behavior of bincode…\nDecoder-based structs and traits.\nAttempt to decode a given type <code>D</code> from the given Reader.\nAttempt to decode a given type <code>D</code> from the given slice. …\nDecode type <code>D</code> from the given reader with the given <code>Config</code>. …\nEncoder-based structs and traits.\nEncode the given value into the given slice. Returns the …\nEncode the given value into any type that implements …\nEncode the given value into a custom Writer.\nEncode the given value into a <code>Vec&lt;u8&gt;</code> with the given <code>Config</code>…\nErrors that can be encounting by Encoding and Decoding.\nHelper macro to implement <code>BorrowDecode</code> for any type that …\nMigrating from bincode 1 to 2\nSerialization specification\nEncodes all integer types in big endian.\nIndicates a type is valid for controlling the bincode …\nThe Configuration struct is used to build bincode …\nUse fixed-size integer encoding.\nSets the byte limit to N.\nEncodes all integer types in little endian.\nSets an unlimited byte limit.\nSkip writing the length of fixed size arrays (<code>[u8; N]</code>) …\nUse variable integer encoding.\nWrite the length of fixed size arrays (<code>[u8; N]</code>) before …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates the “legacy” default config. This is the …\nSkip writing the length of fixed size arrays (<code>[u8; N]</code>) …\nThe default config for bincode 2.0. By default this will …\nMakes bincode encode all integer types in big endian.\nFixed-size integer encoding.\nSets the byte limit to <code>limit</code>.\nMakes bincode encode all integer types in little endian.\nClear the byte limit.\nMakes bincode encode all integer types with a variable …\nWrite the length of fixed size arrays (<code>[u8; N]</code>) before …\nThe concrete BorrowReader type\nTrait that makes a type able to be decoded, akin to serde…\nAny source that can decode basic types. This type is most …\nThe concrete Config type\nTrait that makes a type able to be decoded, akin to serde…\nAny source that can decode basic types. This type is most …\nA Decoder that reads bytes from a given reader <code>R</code>.\nThe concrete Reader type\nAttempt to decode this type with the given BorrowDecode.\nRerturns a mutable reference to the borrow reader\nClaim that <code>n</code> bytes are going to be read from the decoder. …\nClaim that we’re going to read a container which …\nReturns a reference to the config\nAttempt to decode this type with the given Decode.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstruct a new Decoder\nThis module contains reader-based structs and traits.\nReturns a mutable reference to the reader\nNotify the decoder that <code>n</code> bytes are being reclaimed.\nA reader for borrowed data. Implementors of this must also …\nA reader for owned data. See the module documentation for …\nA reader type for <code>&amp;[u8]</code> slices. Implements both Reader and …\nIf an implementation of <code>peek_read</code> is provided, an …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstructs a slice reader\nIf this reader wraps a buffer of any kind, this function …\nFill the given <code>bytes</code> argument with values. Exactly the …\nRead exactly <code>length</code> bytes and return a slice to this data. …\nThe concrete Config type\nAny source that can be encoded. This trait should be …\nHelper trait to encode basic types into.\nAn Encoder that writes bytes into a given writer <code>W</code>.\nThe concrete Writer type\nReturns a reference to the config\nEncode a given type.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn the underlying writer\nCreate a new Encoder\nThis module contains writer-based structs and traits.\nReturns a mutable reference to the writer\nA helper struct that implements <code>Writer</code> for a <code>&amp;[u8]</code> slice.\nTrait that indicates that a struct can be used as a …\nReturn the amount of bytes written so far.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new instance of <code>SliceWriter</code> with the given byte …\nWrite <code>bytes</code> to the underlying writer. Exactly <code>bytes.len()</code> …\nEach one of these values is allowed\nIndicates which enum variants are allowed\nThe decoder tried to decode an array of length <code>required</code>, …\nThe decoder tried to decode a <code>CString</code>, but the incoming …\nErrors that can be encountered by decoding a type\nTried to decode an enum with no variants\nErrors that can be encountered by encoding a type\nInteger types. Used by DecodeError. These types have no …\nThe decoder tried to decode a <code>bool</code> and failed. The given …\nThe decoder tried to decode a <code>char</code> and failed. The given …\nThe decoder tried to decode a Duration and overflowed the …\nInvalid type was found. The decoder tried to read type …\nA <code>std::path::Path</code> was being encoded but did not contain a …\nThe encoder tried to encode a <code>SystemTime</code>, but it was …\nThe decoder tried to decode a SystemTime and overflowed\nThe targeted writer encountered an <code>std::io::Error</code>\nThe reader encountered an IO error but more bytes were …\nThe given configuration limit was exceeded\nThe encoder tried to encode a <code>Mutex</code> or <code>RwLock</code>, but the …\nThe decoder tried to decode any of the <code>NonZero*</code> types but …\nAn uncommon error occurred, see the inner text for more …\nAn uncommon error occurred, see the inner text for more …\nAn uncommon error occurred, see the inner text for more …\nThe encoded value is outside of the range of the target …\nAll values between <code>min</code> and <code>max</code> (inclusive) are allowed\nThe RefCell is already borrowed\nThe writer ran out of storage.\nThe reader reached its end but more bytes were expected.\nInvalid enum variant was found. The decoder tried to …\nThe decoder tried to decode a <code>str</code>, but an utf8 error was …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGives an estimate of how many extra bytes are needed.\nGives an estimate of how many extra bytes are needed.\nThe variants that are allowed\nThe duration which could not have been added to <code>UNIX_EPOCH</code>\nThe type that was being read from the reader\nThe type that was encoded in the data\nThe index of the enum that the decoder encountered\nThe length of the array found in the binary format.\nThe inner error\nThe IO error expected\nThe number of nanoseconds in the duration, which when …\nThe type that was being read from the reader\nNul byte position\nThe length of the array required by the rust type.\nThe number of seconds in the duration.\nThe type name that was being decoded.\nThe type that was being decoded\nThe amount of bytes that were written before the error …\nThe inner borrow error\nThe encountered error\nThe error that was thrown by the SystemTime\nThe SystemTime that caused the error\nthe type name of the RefCell being encoded that is …\nThe type name of the mutex for debugging purposes")
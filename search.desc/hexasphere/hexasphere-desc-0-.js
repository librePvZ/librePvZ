searchState.loadedDescShard("hexasphere", 0, "Library for subdividing shapes made of triangles.\nDefines the setup for a base shape, and the functions used …\nNumber of unique edges defined in the contents of …\nA progressively subdivided shape which can record the …\nA main triangle on the base shape of a subdivided shape.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the indices for all main triangles in the shape.\nGets the wireframe indices for all main triangles in the …\nAppends the indices for the triangle into <code>buffer</code>.\nGets the wireframe indices for the contents of a specified …\nGets the wireframe indices for the specified edge of the …\nCalculate the number of indices which each main triangle …\nThe initial vertices for the triangle. Note that <code>Vec3A::new</code>…\nBasic function used for interpolation. When <code>p</code> is <code>0.0</code>, <code>a</code> is …\nIf an optimization is available for the case where <code>p</code> is <code>0.5</code>…\nIf an optimization is available for the case where <code>p</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLinear distance between two points on this shape.\nCreates a new <code>Triangle</code> given the data. This is done to …\nCreates the base shape from <code>S</code> and subdivides it.\nCalculate distance from the center of a shape (pentagon or …\nReturns the custom data created by the generator function.\nThe raw points created by the subdivision process.\nCalculate the number of vertices along the edges of the …\nSubdivides all triangles. <code>calculate</code> signals whether or not …\nReturns the number of subdivisions applied when this shape …\nBase triangles for the shape.\nCalculate the number of vertices contained within each …\nCalculate the number of vertices contained within each …\nImplements spherical interpolation along the great arc …\nThis is an optimization for the <code>geometric_slerp</code> in the …\nThis is an optimization for the case where multiple points …\nSimple linear interpolation. No weirdness here.\nGives the average of the two points.\nThis is provided as a plug in for people who need it, but …\nPerforms normalized linear interpolation. This creates …\nThis is an optimization of <code>normalized_lerp</code> which avoids a …\nThis is provided as a plug in for people who need it, but …\nImplements a cube as the base shape.\nA cube sphere.\nIcosphere.\nImplements an icosahedron as the base shape.\nNormalized Icosphere.\nImplements the same shape as <code>IcoSphereBase</code>, however it …\nImplements a square as the base shape.\nA square.\nTetrasphere (Sphere from tetrahedron).\nImplements a tetrahedron as the base shape.\nImplements a single triangle as the base shape.\nA triangle.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalculate distance from the center of a shape (pentagon or …")
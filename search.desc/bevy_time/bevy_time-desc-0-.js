searchState.loadedDescShard("bevy_time", 0, "Bevy Time\n<code>Time</code> will be automatically updated each frame using an …\nThe message could not be sent because the channel is …\nThe fixed timestep game clock following virtual time.\nThe message could not be sent because the channel is full.\n<code>Time</code> will be incremented by the specified <code>Duration</code> each …\n<code>Time</code> will be updated to the specified <code>Instant</code> value each …\nRun once and stop.\nReal time clock representing elapsed wall clock time.\nReset when finished.\nA Stopwatch is a struct that track elapsed time when …\nA generic clock resource that tracks how much it has …\nAdds time functionality to Apps.\nChannel resource used to receive time from the render …\nChannel resource used to send time from the render world.\nUpdates the elapsed time. Any system that interacts with …\nConfiguration resource used to determine how the time …\nTracks elapsed time. Enters the finished state once …\nSpecifies <code>Timer</code> behavior.\nAn error returned from the <code>try_send</code> method.\nThe virtual game clock representing game time.\nAdvance this clock by adding a <code>delta</code> duration to it.\nAdvance this clock to a specific <code>elapsed</code> time.\nReturns a copy of this clock as fully generic clock …\nCommon run conditions\nReturns a reference to the context of this specific clock.\nReturns a mutable reference to the context of this …\nCreates channels used for sending time between the render …\nReturns how much time has advanced since the last <code>update</code>, …\nReturns how much time has advanced since the last <code>update</code>, …\nReturns how much time has advanced since the last <code>update</code>, …\nDiscard a part of the overstep amount.\nReturns the duration of the timer.\nReturns the speed the clock advanced relative to your …\nReturns the speed the clock advanced relative to your …\nReturns the elapsed time since the last <code>reset</code> of the …\nReturns how much time has advanced since <code>startup</code>, as …\nReturns the time elapsed on the timer. Guaranteed to be …\nReturns how much time has advanced since <code>startup</code>, as <code>f32</code> …\nReturns how much time has advanced since <code>startup</code>, as <code>f64</code> …\nReturns how much time has advanced since <code>startup</code> modulo …\nReturns how much time has advanced since <code>startup</code> modulo …\nReturns the elapsed time since the last <code>reset</code> of the …\nReturns the time elapsed on the timer as an <code>f32</code>. See also …\nReturns the elapsed time since the last <code>reset</code> of the …\nReturns how much time has advanced since <code>startup</code> modulo …\nReturns <code>true</code> if the timer has reached its duration.\nReturns the <code>Instant</code> when <code>Self::update</code> was first called, if …\nReturns the fraction of the timer elapsed time (goes from …\nReturns the fraction of the timer remaining time (goes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn new fixed time clock with given timestep as <code>Duration</code>\nReturn new fixed time clock with given timestep frequency …\nCreate new virtual clock with given maximum delta step …\nReturn new fixed time clock with given timestep seconds as …\nCreates a new timer with a given duration in seconds.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnwraps the message.\nReturns <code>true</code> if the send operation failed because the …\nReturns <code>true</code> if the send operation failed because the …\nReturns <code>true</code> if the clock is currently paused.\nReturns <code>true</code> only on the tick the timer reached its …\nReturns the <code>Instant</code> when <code>Self::update</code> was last called, if …\nReturns the maximum amount of time that can be added to …\nReturns the mode of the timer.\nCreate a new unpaused <code>Stopwatch</code> with no elapsed time.\nConstructs a new <code>Time&lt;Real&gt;</code> instance with a specific …\nCreates a new timer with a given duration.\nCreate a new clock from context with <code>Self::delta</code> and …\nReturns the amount of overstep time accumulated toward new …\nReturns the amount of overstep time accumulated toward new …\nReturns the amount of overstep time accumulated toward new …\nPauses the stopwatch. Any call to <code>tick</code> while paused will …\nStops the clock, preventing it from advancing until …\nPauses the Timer. Disables the ticking of the timer.\nReturns <code>true</code> if the stopwatch is paused.\nReturns <code>true</code> if the timer is paused.\nThe Bevy Time Prelude.\nReturns the speed the clock advances relative to your …\nReturns the speed the clock advances relative to your …\nReturns the remaining time using Duration\nReturns the remaining time in seconds\nResets the stopwatch. The reset doesn’t affect the …\nResets the timer. The reset doesn’t affect the <code>paused</code> …\nRuns <code>FixedMain</code> zero or more times based on delta of …\nSets the duration of the timer.\nSets the elapsed time of the stopwatch.\nSets the elapsed time of the timer without any other …\nSets the maximum amount of time that can be added to this …\nSets the mode of the timer.\nSets the speed the clock advances relative to your system …\nSets the speed the clock advances relative to your system …\nSets the amount of virtual time that must pass before the …\nSets the amount of virtual time that must pass before the …\nSets the amount of virtual time that must pass before the …\nSets the modulus used to calculate <code>elapsed_wrapped</code>.\nReturns the <code>Instant</code> the clock was created.\nAdvance the stopwatch by <code>delta</code> seconds. If the stopwatch …\nAdvance the timer by <code>delta</code> seconds. Non repeating timer …\nThe system used to update the <code>Time</code> used by app logic. If …\nReturns the number of times a repeating timer finished …\nReturns the amount of virtual time that must pass before …\nUnpauses the stopwatch. Resume the effect of ticking on …\nResumes the clock if paused.\nUnpauses the Timer. Resumes the ticking of the timer.\nUpdates the internal time measurements.\nAdvances <code>Time&lt;Virtual&gt;</code> and <code>Time</code> based on the elapsed …\nUpdates time with a specified <code>Duration</code>.\nUpdates time with a specified <code>Instant</code>.\nReturns <code>true</code> if the clock was paused at the start of this …\nReturns the modulus used to calculate <code>elapsed_wrapped</code>.\nRun condition that is active on a regular time interval, …\nRun condition that is active on a regular time interval, …\nRun condition that is active <em>once</em> after the specified …\nRun condition that is active <em>once</em> after the specified …\nRun condition that is active when the <code>Time&lt;Virtual&gt;</code> clock …\nRun condition that is active <em>indefinitely</em> after the …\nRun condition that is active <em>indefinitely</em> after the …")